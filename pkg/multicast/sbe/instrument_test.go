package sbe

import (
	"bytes"
	"io"
	"math"
	"reflect"
	"testing"

	"github.com/KyberNetwork/deribit-api/pkg/common"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDecodeInstrument(t *testing.T) {
	eth8bytes := [8]byte{}
	btc8bytes := [8]byte{}
	usd8bytes := [8]byte{}
	copy(eth8bytes[:], "ETH")
	copy(btc8bytes[:], "BTC")
	copy(usd8bytes[:], "USD")

	tests := []struct {
		event          []byte
		expectedOutput Instrument
		expectedError  error
	}{
		// success cases
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x4a, 0x37, 0x03, 0x00,
				0x01, 0x01, 0x00, 0x02, 0x00, 0x05, 0x03, 0x00, 0x45, 0x54, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x45, 0x54, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x53, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x45, 0x54, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x54, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x60, 0x72, 0xf1, 0xba, 0x7f, 0x01, 0x00, 0x00, 0x00, 0x38, 0xae, 0x36, 0x87, 0x01, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xab, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0xfc, 0xa9, 0xf1, 0xd2, 0x4d, 0x62, 0x40, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x45, 0x54, 0x48, 0x2d, 0x33, 0x31, 0x4d,
				0x41, 0x52, 0x32, 0x33, 0x2d, 0x33, 0x35, 0x30, 0x30, 0x2d, 0x50,
			},
			Instrument{
				InstrumentId:             210762,
				InstrumentState:          InstrumentState.Open,
				Kind:                     InstrumentKind.Option,
				FutureType:               FutureType.NotApplicable,
				OptionType:               OptionType.Put,
				Rfq:                      YesNo.No,
				SettlementPeriod:         Period.Month,
				SettlementPeriodCount:    3,
				BaseCurrency:             eth8bytes,
				QuoteCurrency:            eth8bytes,
				CounterCurrency:          usd8bytes,
				SettlementCurrency:       eth8bytes,
				SizeCurrency:             eth8bytes,
				CreationTimestampMs:      1648108860000,
				ExpirationTimestampMs:    1680249600000,
				StrikePrice:              3500,
				ContractSize:             1,
				MinTradeAmount:           1,
				TickSize:                 0.0005,
				MakerCommission:          0.0003,
				TakerCommission:          0.0003,
				BlockTradeCommission:     0.0003,
				MaxLiquidationCommission: 0,
				MaxLeverage:              0,
				InstrumentName:           []uint8("ETH-31MAR23-3500-P"),
			},
			nil,
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xdb, 0x64, 0x03, 0x00,
				0x01, 0x01, 0x00, 0x02, 0x00, 0x05, 0x03, 0x00, 0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x53, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x28, 0x43, 0x8a, 0xb4, 0x81, 0x01, 0x00, 0x00, 0x00, 0xec, 0x50, 0x0b, 0x89, 0x01, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x6a, 0xf8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
				0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f, 0xfc, 0xa9, 0xf1, 0xd2, 0x4d, 0x62, 0x40, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x14, 0x42, 0x54, 0x43, 0x2d, 0x33, 0x30, 0x4a,
				0x55, 0x4e, 0x32, 0x33, 0x2d, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x2d, 0x50, 0x85,
			},
			Instrument{
				InstrumentId:             222427,
				InstrumentState:          InstrumentState.Open,
				Kind:                     InstrumentKind.Option,
				FutureType:               FutureType.NotApplicable,
				OptionType:               OptionType.Put,
				Rfq:                      YesNo.No,
				SettlementPeriod:         Period.Month,
				SettlementPeriodCount:    3,
				BaseCurrency:             btc8bytes,
				QuoteCurrency:            btc8bytes,
				CounterCurrency:          usd8bytes,
				SettlementCurrency:       btc8bytes,
				SizeCurrency:             btc8bytes,
				CreationTimestampMs:      1656591369000,
				ExpirationTimestampMs:    1688112000000,
				StrikePrice:              100000,
				ContractSize:             1,
				MinTradeAmount:           0.1,
				TickSize:                 0.0005,
				MakerCommission:          0.0003,
				TakerCommission:          0.0003,
				BlockTradeCommission:     0.0003,
				MaxLiquidationCommission: math.NaN(),
				MaxLeverage:              math.NaN(),
				InstrumentName:           []uint8("BTC-30JUN23-100000-P"),
			},
			nil,
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x67, 0x82, 0x03, 0x00,
				0x01, 0x01, 0x00, 0x01, 0x00, 0x04, 0x01, 0x00, 0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x53, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x28, 0x87, 0x10, 0xf8, 0x82, 0x01, 0x00, 0x00, 0x00, 0x4c, 0x5c, 0x69, 0x83, 0x01, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xdf, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
				0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f, 0xfc, 0xa9, 0xf1, 0xd2, 0x4d, 0x62, 0x40, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0x42, 0x54, 0x43, 0x2d, 0x32, 0x33, 0x53,
				0x45, 0x50, 0x32, 0x32, 0x2d, 0x33, 0x32, 0x30, 0x30, 0x30, 0x2d, 0x43, 0x85,
			},
			Instrument{
				InstrumentId:             229991,
				InstrumentState:          InstrumentState.Open,
				Kind:                     InstrumentKind.Option,
				FutureType:               FutureType.NotApplicable,
				OptionType:               OptionType.Call,
				Rfq:                      YesNo.No,
				SettlementPeriod:         Period.Week,
				SettlementPeriodCount:    1,
				BaseCurrency:             btc8bytes,
				QuoteCurrency:            btc8bytes,
				CounterCurrency:          usd8bytes,
				SettlementCurrency:       btc8bytes,
				SizeCurrency:             btc8bytes,
				CreationTimestampMs:      1662019209000,
				ExpirationTimestampMs:    1663920000000,
				StrikePrice:              32000,
				ContractSize:             1,
				MinTradeAmount:           0.1,
				TickSize:                 0.0005,
				MakerCommission:          0.0003,
				TakerCommission:          0.0003,
				BlockTradeCommission:     0.0003,
				MaxLiquidationCommission: math.NaN(),
				MaxLeverage:              math.NaN(),
				InstrumentName:           []uint8("BTC-23SEP22-32000-C"),
			},
			nil,
		},
		// decode fail cases
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
			},
			Instrument{},
			io.EOF, // instrumentId
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
			},
			Instrument{},
			io.EOF, // instrumentState
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
				0x01,
			},
			Instrument{},
			io.EOF, // instrumentKind
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
				0x01, 0x01,
			},
			Instrument{},
			io.EOF, // futureType
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
				0x01, 0x01, 0x00,
			},
			Instrument{},
			io.EOF, // futureType
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
				0x01, 0x01, 0x00, 0x01,
			},
			Instrument{},
			io.EOF, // rfq
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
				0x01, 0x01, 0x00, 0x01, 0x00,
			},
			Instrument{},
			io.EOF, // settlementPeriod
		},
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x49, 0x37, 0x03, 0x00,
				0x01, 0x01, 0x00, 0x01, 0x00, 0x05,
			},
			Instrument{},
			io.EOF, // settlementPeriod
		},

		// range check fail cases
		{
			[]byte{
				0x8c, 0x00, 0xe8, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x67, 0x82, 0x03, 0x00,
				0x01, 0xb1, 0x00, 0x01, 0x00, 0x04, 0x01, 0x00, 0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x53, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x54, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x28, 0x87, 0x10, 0xf8, 0x82, 0x01, 0x00, 0x00, 0x00, 0x4c, 0x5c, 0x69, 0x83, 0x01, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xdf, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
				0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f, 0xfc, 0xa9, 0xf1, 0xd2, 0x4d, 0x62, 0x40, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f,
				0x61, 0x32, 0x55, 0x30, 0x2a, 0xa9, 0x33, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0x42, 0x54, 0x43, 0x2d, 0x32, 0x33, 0x53,
				0x45, 0x50, 0x32, 0x32, 0x2d, 0x33, 0x32, 0x30, 0x30, 0x30, 0x2d, 0x43, 0x85,
			},
			Instrument{},
			ErrRangeCheck,
		},
	}

	marshaller := NewSbeGoMarshaller()
	insPtr := reflect.TypeOf(&Instrument{})

	for _, test := range tests {
		bufferData := bytes.NewBuffer(test.event)

		var header MessageHeader
		err := header.Decode(marshaller, bufferData)
		require.NoError(t, err)

		err = header.RangeCheck()
		require.NoError(t, err)

		var ins Instrument
		err = ins.Decode(marshaller, bufferData, header.BlockLength, true)
		require.ErrorIs(t, err, test.expectedError)

		if err == nil {
			common.ReplaceNaNValueOfStruct(&ins, insPtr)
			common.ReplaceNaNValueOfStruct(&test.expectedOutput, insPtr)
			assert.Equal(t, ins, test.expectedOutput)
		}
	}
}

func TestInstrumentIsActive(t *testing.T) {
	tests := []struct {
		state    InstrumentStateEnum
		expected bool
	}{
		{
			state:    InstrumentState.Created,
			expected: true,
		},
		{
			state:    InstrumentState.Open,
			expected: true,
		},
		{
			state:    InstrumentState.Closed,
			expected: false,
		},
		{
			state:    InstrumentState.Settled,
			expected: true,
		},
		{
			state:    InstrumentState.NullValue,
			expected: false,
		},
	}

	for _, test := range tests {
		assert.Equal(t, test.expected, test.state.IsActive())
	}
}
